#include "battle_city.h"
#include "map.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"
#include <math.h>

/*
 * GENERATED BY BC_MEM_PACKER
 * DATE: Wed Jul 08 21:00:48 2015
 */

// ***** 16x16 IMAGES *****
#define IMG_16x16_background			    0x0100  //0
#define IMG_16x16_bang			            0x0140  //1
#define IMG_16x16_car_blue			        0x0180  //2
#define IMG_16x16_car_red			        0x01C0  //3
#define IMG_16x16_flag			            0x0200  //4
#define IMG_16x16_map_element_00			0x0240  //5
#define IMG_16x16_map_element_01			0x0280  //6
#define IMG_16x16_map_element_02			0x02C0  //7
#define IMG_16x16_map_element_03			0x0300  //8
#define IMG_16x16_map_element_04			0x0340  //9
#define IMG_16x16_map_element_05			0x0380  //a
#define IMG_16x16_map_element_06			0x03C0  //b
#define IMG_16x16_map_element_07			0x0400  //c
#define IMG_16x16_map_element_08			0x0440  //d
#define IMG_16x16_map_element_09			0x0480  //e
#define IMG_16x16_map_element_10			0x04C0  //f
#define IMG_16x16_map_element_11			0x0500  //g
#define IMG_16x16_map_element_12			0x0540  //h
#define IMG_16x16_map_element_13			0x0580  //i
#define IMG_16x16_map_element_14			0x05C0  //j
#define IMG_16x16_map_element_15			0x0600  //k
#define IMG_16x16_map_element_16			0x0640  //l
#define IMG_16x16_map_element_17			0x0680  //m
#define IMG_16x16_map_element_18			0x06C0  //n
#define IMG_16x16_map_element_19			0x0700  //o
#define IMG_16x16_map_element_20			0x0740  //p
#define IMG_16x16_map_element_21			0x0780  //q
#define IMG_16x16_map_element_22			0x07C0  //r
#define IMG_16x16_map_element_23			0x0800  //s
#define IMG_16x16_map_element_24			0x0840  //t
#define IMG_16x16_map_element_25			0x0880  //u
#define IMG_16x16_rock			            0x08C0  //v
#define IMG_16x16_smoke			            0x0900  //w

// ***** MAP *****

#define MAP_BASE_ADDRESS			    2368  // MAP_OFFSET in battle_city.vhd
#define MAP_X							0
#define MAP_X2							640
#define MAP_Y							4
#define MAP_W							64
#define MAP_H							56

#define SPRITES_REG_OFFSET               4096
#define OFFSET_ROW_REG_OFFSET (4096+2048+0)
#define OFFSET_COL_REG_OFFSET (4096+2048+1)
#define STAT_IMG_SIZE_IS_16_REG_OFFSET (4096+2048+2)


#define BTN_DOWN( b )                   ( !( b & 0x01 ) )
#define BTN_UP( b )                     ( !( b & 0x10 ) )
#define BTN_LEFT( b )                   ( !( b & 0x02 ) )
#define BTN_RIGHT( b )                  ( !( b & 0x08 ) )
#define BTN_SHOOT( b )                  ( !( b & 0x04 ) )

#define TANK1_REG_L                     8
#define TANK1_REG_H                     9
#define TANK_AI_REG_L                   4
#define TANK_AI_REG_H                   5
#define TANK_AI_REG_L2                  6
#define TANK_AI_REG_H2                  7
#define TANK_AI_REG_L3                  2
#define TANK_AI_REG_H3                  3
#define TANK_AI_REG_L4                  10
#define TANK_AI_REG_H4                  11
#define TANK_AI_REG_L5                  12
#define TANK_AI_REG_H5                  13
#define TANK_AI_REG_L6                  14
#define TANK_AI_REG_H6                  15
#define TANK_AI_REG_L7                  16
#define TANK_AI_REG_H7                  17
#define BASE_REG_L						0
#define BASE_REG_H	                    1

int lives = 0;
int score = 0;
int mapPart = 1;
int udario_glavom_skok = 0;
int map_move = 0;
int brojac = 0;
int udario_u_blok = 0;

int mario_se_pomerio = 0;

int mario_map_x = 16;
int mario_map_y = 9;

typedef enum {
	b_false, b_true
} bool_t;

typedef enum {
	DIR_LEFT, DIR_RIGHT, DIR_UP, DIR_DOWN, DIR_STILL
} direction_t;

typedef struct {
	unsigned int x;
	unsigned int y;
	direction_t dir;
	unsigned int type;

	bool_t destroyed;

	// Sta je reg_l, reg_h
	unsigned int reg_l;
	unsigned int reg_h;
} characters;

characters mario = {
		320,	                          // x
		240, 		                     // y
		DIR_RIGHT,              		// dir
		IMG_16x16_car_blue,  			// type

		b_false,                		// destroyed

		TANK1_REG_L,            		// reg_l
		TANK1_REG_H             		// reg_h
		};

characters enemie1 = { 331,						// x
		431,						// y
		DIR_LEFT,              		// dir
		IMG_16x16_car_red,  		// type

		b_false,                		// destroyed

		TANK_AI_REG_L,            		// reg_l
		TANK_AI_REG_H             		// reg_h
		};
/*
characters enemie2 = { 450,						// x
		431,						// y
		DIR_LEFT,              		// dir
		IMG_16x16_enemi1,  		// type

		b_false,                		// destroyed

		TANK_AI_REG_L2,            		// reg_l
		TANK_AI_REG_H2             		// reg_h
		};

characters enemie3 = { 330,						// x
		272,						// y
		DIR_LEFT,              		// dir
		IMG_16x16_enemi1,  		// type

		b_false,                		// destroyed

		TANK_AI_REG_L3,            		// reg_l
		TANK_AI_REG_H3             		// reg_h
		};

characters enemie4 = { 635,						// x
		431,						// y
		DIR_LEFT,              		// dir
		IMG_16x16_enemi1,  		// type

		b_false,                		// destroyed

		TANK_AI_REG_L4,            		// reg_l
		TANK_AI_REG_H4             		// reg_h
		};
*/



unsigned int rand_lfsr113(void) {
	static unsigned int z1 = 12345, z2 = 12345;
	unsigned int b;

	b = ((z1 << 6) ^ z1) >> 13;
	z1 = ((z1 & 4294967294U) << 18) ^ b;
	b = ((z2 << 2) ^ z2) >> 27;
	z2 = ((z2 & 4294967288U) << 2) ^ b;

	return (z1 ^ z2);
}

static void chhar_spawn(characters * chhar) {
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + chhar->reg_l ),
			(unsigned int )0x8F000000 | (unsigned int )chhar->type);
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + chhar->reg_h ),
			(chhar->y << 16) | chhar->x);
}

static void map_update(characters * mario) {
	int x, y;

	long int addr;


/*
		if(mario_se_pomerio == 1){
				if((mario->x >= 450) && (mario->x <= 640)){
					if (udario_u_blok <= 0) {
						if(map_move < 10){
							map_move++;
							mario->x--;
						}
					}
				}
				if((mario->x >= 100) && (mario->x <= 150)){
									if (udario_u_blok <= 0) {
										if(map_move < 10){
											map_move--;
											mario->x++;
										}
									}
								}

				mario_se_pomerio = 0;
		}

	*/

	int current_mario_map_x = mario->x /16;
	int current_mario_map_y = mario->y /16;
	//printf(" map x is: %d",current_mario_map_x);

	int i = current_mario_map_x - mario_map_x;
	int j = current_mario_map_y - mario_map_y;

	mario_map_x = current_mario_map_x;
	mario_map_y = current_mario_map_y;


	float Xx;
	float Yy;
	int roundX = 0;
	int roundY = 0;

	Xx = mario->x;
	Yy = mario->y;

	roundX = floor(Xx / 16);
	roundY = floor(Yy / 16);

	int z,w;

	for (y = 0; y < MAP_HEIGHT; y++) {
			for (x = 0; x < MAP_WIDTH; x++) {
				addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
						+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
				switch (map1[(roundY-15)+y][(roundX-20)+x]) {
				//switch (map1[y][x]) {
				case '0':
					Xil_Out32(addr, IMG_16x16_background);
					break;
				case '1':
					Xil_Out32(addr, IMG_16x16_bang);
					break;
				case '2':
					Xil_Out32(addr, IMG_16x16_car_blue);
					break;
				case '3':
					Xil_Out32(addr, IMG_16x16_car_red);
					break;
				case '4':
					Xil_Out32(addr, IMG_16x16_flag);
					break;
				case '5':
					Xil_Out32(addr, IMG_16x16_map_element_00);
					break;
				case '6':
					Xil_Out32(addr, IMG_16x16_map_element_01);
					break;
				case '7':
					Xil_Out32(addr, IMG_16x16_map_element_02);
					break;
				case '8':
					Xil_Out32(addr, IMG_16x16_map_element_03);
					break;
				case '9':
					Xil_Out32(addr, IMG_16x16_map_element_04);
					break;
				case 'a':
					Xil_Out32(addr, IMG_16x16_map_element_05);
					break;
				case 'b':
					Xil_Out32(addr, IMG_16x16_map_element_06);
					break;
				case 'c':
					Xil_Out32(addr, IMG_16x16_map_element_07);
					break;
				case 'd':
					Xil_Out32(addr, IMG_16x16_map_element_08);
					break;
				case 'e':
					Xil_Out32(addr, IMG_16x16_map_element_09);
					break;
				case 'f':
					Xil_Out32(addr, IMG_16x16_map_element_10);
					break;
				case 'g':
					Xil_Out32(addr, IMG_16x16_map_element_11);
					break;
				case 'h':
					Xil_Out32(addr, IMG_16x16_map_element_12);
					break;
				case 'i':
					Xil_Out32(addr, IMG_16x16_map_element_13);
					break;
				case 'j':
					Xil_Out32(addr, IMG_16x16_map_element_14);
					break;
				case 'k':
					Xil_Out32(addr, IMG_16x16_map_element_15);
					break;
				case 'l':
					Xil_Out32(addr, IMG_16x16_map_element_16);
					break;
				case 'm':
					Xil_Out32(addr, IMG_16x16_map_element_17);
					break;
				case 'n':
					Xil_Out32(addr, IMG_16x16_map_element_18);
					break;
				case 'o':
					Xil_Out32(addr, IMG_16x16_map_element_19);
					break;
				case 'p':
					Xil_Out32(addr, IMG_16x16_map_element_20);
					break;
				case 'q':
					Xil_Out32(addr, IMG_16x16_map_element_21);
					break;
				case 'r':
					Xil_Out32(addr, IMG_16x16_map_element_22);
					break;
				case 's':
					Xil_Out32(addr, IMG_16x16_map_element_23);
					break;
				case 't':
					Xil_Out32(addr, IMG_16x16_map_element_24);
					break;
				case 'u':
					Xil_Out32(addr, IMG_16x16_map_element_25);
					break;
				case 'v':
					Xil_Out32(addr,IMG_16x16_rock );
					break;
				case 'w':
					Xil_Out32(addr, IMG_16x16_smoke);
					break;

				default:
					Xil_Out32(addr, IMG_16x16_background);
					break;
				}
			}

		}


}

static void map_reset(unsigned char * map) {

	unsigned int i;

	for (i = 0; i <= 20; i += 2) {
		Xil_Out32(
				XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + i ),
				(unsigned int )0x0F000000);
	}

}

static bool_t mario_move(unsigned char * map, characters * mario,
		direction_t dir, int start_jump) {



	unsigned int x;
	unsigned int y;
	int i, j;

	float Xx;
	float Yy;
	int roundX = 0;
	int roundY = 0;
	u8 offset_x;
	u8 offset_y;

	int obstackle = 0;

	if(dir == DIR_RIGHT){
		mario->x+=3;
	}
	x = mario->x;
	y = mario->y;

	offset_x = x & 0xf; // % 16

	Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_COL_REG_OFFSET, offset_x);

	if(dir == DIR_LEFT){
			mario->x-=3;
		}
		x = mario->x;
		y = mario->y;

		offset_x = x & 0xf; // % 16

		Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_COL_REG_OFFSET, offset_x);

	if(dir == DIR_UP){
			mario->y-=3;
		}
		x = mario->x;
		y = mario->y;

		offset_y = y & 0xf; // % 16

		Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_ROW_REG_OFFSET, offset_y);
	if(dir == DIR_DOWN){
			mario->y+=3;
		}
		x = mario->x;
		y = mario->y;

		offset_y = y & 0xf; // % 16

		Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_ROW_REG_OFFSET, offset_y);




	return b_false;


	while (brojac != 0) {
		y++;
		brojac--;
	}

	Xx = x;
	Yy = y;

	if (dir == DIR_LEFT) {
		obstackle = obstackles_detection(x, y, mapPart, map, 2);
	} else if (dir == DIR_RIGHT) {
		obstackle = obstackles_detection(x, y, mapPart, map, 1);
	} else if (dir == DIR_UP) {
		obstackle = obstackles_detection(x, y, mapPart, map, 3);
	} else if (dir == DIR_DOWN) {
		obstackle = obstackles_detection(x, y, mapPart, map, 4);
	}

	roundX = floor(Xx / 16);
	roundY = floor(Yy / 16);

	switch (obstackle) {
	case 0:{
		udario_u_blok = 0;
	}
	break;
	case 2: {
		//blok
		if (dir == DIR_LEFT) {
			Xil_Out32(OFFSET_COL_REG_OFFSET, 1);
		} else if (dir == DIR_RIGHT) {
			Xil_Out32(OFFSET_COL_REG_OFFSET, -1);
		} else if (dir == DIR_UP) {
			y++;
		} else if (dir == DIR_DOWN) {
			y--;
		}

		udario_u_blok = 1;
	}
		break;
	case 3: {
		//cigla

		if (dir == DIR_LEFT) {
			if (x > MAP_X * 16) {
				x++;
			}
		} else if (dir == DIR_RIGHT) {
			x--;
		}
		udario_u_blok = 1;
	}
		break;
	case 5: {
		//coin
		score++;
		map1[roundY + 1][roundX + 1] = 0;
		map_update(&mario);
	}
		break;
	default:
		udario_u_blok = 0;
	}

	mario->x = x;
	mario->y = y;

	/*
	if(dir == DIR_RIGHT){
		if( (mario->x % 16) == 15)
			Xil_Out32(
						XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + mario->reg_h ),
						(((mario->y%16)+240) << 16) | (10)+320);


	}

	else{
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + mario->reg_h ),
			(((mario->y%16)+240)  << 16) | (mario->x%16)+320);
	}
	*/

	return b_false;
}

int obstackles_detection(int x, int y, int deoMape, unsigned char * map,
		int dir) {
	unsigned char mario_position_right;
	unsigned char mario_position_left;
	unsigned char mario_position_up;
	unsigned char mario_position_down;

	float Xx = x;
	float Yy = y;

	int roundX = 0;
	int roundY = 0;

	roundX = floor(Xx / 16);
	roundY = floor(Yy / 16);

	mario_position_right = map1[roundY + 1][roundX + 1];
	mario_position_left = map1[roundY + 1][roundX];
	mario_position_up = map1[roundY][roundX];
	mario_position_down = map1[roundY + 1][roundX];

	if (dir == 1) {
		switch (mario_position_right) {
		case 0:
			return 0;
			break;
		case 1:
			return 1;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 3;
			break;
		case 4:
			return 4;
			break;
		case 5:
			return 5;
			break;

		}
	} else if (dir == 2) {
		switch (mario_position_left) {
		case 0:
			return 0;
			break;
		case 1:
			return 1;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 3;
			break;
		case 4:
			return 4;
			break;
		case 5:
			return 5;
			break;

		}
	} else if (dir == 3) {
		switch (mario_position_up) {
		case 0:
			return 0;
			break;
		case 1:
			return 1;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 3;
			break;
		case 4:
			return 4;
			break;
		case 5:
			return 5;
			break;

		}
	} else if (dir == 4) {
		switch (mario_position_down) {
		case 0:
			return 0;
			break;
		case 1:
			return 1;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 3;
			break;
		case 4:
			return 4;
			break;
		case 5:
			return 5;
			break;

		}
	}

}

void battle_city() {

	unsigned int buttons, tmpBtn = 0, tmpUp = 0;
	int i, change = 0, jumpFlag = 0;
	int block;

	//map_reset(map1);
//  map_update(&mario);

	//chhar_spawn(&enemie1);
	//chhar_spawn(&enemie2);
	//chhar_spawn(&enemie3);
	//chhar_spawn(&enemie4);
#if 0
	chhar_spawn(&mario);
#elif 0
	chhar_spawn(&mario);
	map_update(&mario);

	// TODO Testing.
	Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_COL_REG_OFFSET, 8);
	Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*OFFSET_ROW_REG_OFFSET, 8);
	//Xil_Out32(XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4*, 1);

	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( SPRITES_REG_OFFSET + 9 ),
			0);
#else
	chhar_spawn(&mario);
	map_update(&mario);


	while (1) {

		buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

		direction_t d = DIR_STILL;
		if (BTN_LEFT(buttons)) {
			d = DIR_LEFT;
		} else if (BTN_RIGHT(buttons)) {
			d = DIR_RIGHT;
		}

		int start_jump = 0;
		/*
		if (BTN_UP (buttons) && (BTN_LEFT(buttons) || BTN_RIGHT(buttons))) {
			start_jump = 1;
		}
		*/

		if (BTN_UP (buttons) && !BTN_LEFT(buttons) && !BTN_RIGHT(buttons)) {
			d = DIR_UP;
		}
		if (BTN_DOWN (buttons) && !BTN_LEFT(buttons) && !BTN_RIGHT(buttons)) {
			d = DIR_DOWN;
		}
		mario_move(map1, &mario, d, start_jump);

		map_update(&mario);

		for (i = 0; i < 100000; i++) {
		}

	}
#endif
}
